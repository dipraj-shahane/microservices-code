Microservices with Spring Cloud

    Step 01 - Part 1 - Introduction to Limits Microservice and Spring Cloud Config Server

    Step 01 - Part 2 - Setting up Limits Microservice

    Step 02 - Creating a hard coded limits service

    Step 03 - Enhance limits service to pick up configuration from application properties

    Step 04 - Setting up Spring Cloud Config Server

    Step 05 - Installing Git

    Step 06 - Creating Local Git Repository

    Step 07 - Connect Spring Cloud Config Server to Local Git Repository

    Step 08 - Configuration for Multiple Environments in Git Repository

    Step 09 - Connect Limits Service to Spring Cloud Config Server

    Step 10 - Configuring Profiles for Limits Service

    Step 11 - A review of Spring Cloud Config Server

    Step 12 - Introduction to Currency Conversion and Currency Exchange Microservices

    Step 13 - Setting up Currency Exchange Microservice

    Step 14 - Create a simple hard coded currency exchange service

    Step 15 - Setting up Dynamic Port in the the Response

    Step 16 - Configure JPA and Initialized Data

    Step 17 - Create a JPA Repository

    Step 18 - Setting up Currency Conversion Microservice

    Step 19 - Creating a service for currency conversion

    Step 20 - Invoking Currency Exchange Microservice from Currency Conversion Microservice

    Step 21 - Using Feign REST Client for Service Invocation

    Step 22 - Setting up client side load balancing with Ribbon

    Step 23 - Running client side load balancing with Ribbon

    Step 24 - Understand the need for a Naming Server

    Step 25 - Setting up Eureka Naming Server

    Step 26 - Connecting Currency Conversion Microservice to Eureka

    Step 27 - Connecting Currency Exchange Microservice to Eureka

    Step 28 - Distributing calls using Eureka and Ribbon

    Step 29 - A review of implementing Eureka, Ribbon and Feign

    Step 30 - Introduction to API Gateways

    Step 31 - Setting up Zuul API Gateway

    Step 32 - Implementing Zuul Logging Filter

    Step 33 - Executing a request through Zuul API Gateway

    Step 34 - Setting up Zuul API Gateway between microservice invocations

    Step 35 - Introduction to Distributed Tracing

    Step 36 - Implementing Spring Cloud Sleuth

    Step 37 - Introduction to Distributed Tracing with Zipkin

    Step 38 - Installing Rabbit MQ

    Step 39 - Setting up Distributed Tracing with Zipkin

    Step 40 - Connecting microservices to Zipkin

    Step 41 - Using Zipkin UI Dashboard to trace requests

    Step 42 - Understanding the need for Spring Cloud Bus

    Step 43 - Implementing Spring Cloud Bus

    Step 44 - Fault Tolerance with Hystrix